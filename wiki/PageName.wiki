#summary One-sentence summary of this page.

= Introduction =

Project Desgin
There are three things you need to implement: 
1) ID space partitioning/re-partitioning, 
2) Ring-based routing, and 
3) Node joins
Content Provider:
Predecessor_node_id
Successor_node_id
Have node_id (avoid using emulator number is a good approach)
(The direction of message transfer is anti-clock wise direction of chord.
The value-space on the ring increases in clock wise direction.
Each node is responsible for objects (keys)  anti-clockwise direction. (keys less than current node_id but greater than previous node_id.
Request forward happens in clockwise direction:
	Successor(curr_node_id) = next_node_id ( hash > current_node_id)
	We need successor node_id to check the current node’s hash space
	And, we require a hash code comparator function.
o	Given hash of key & succ_node_id check if key is between hash_of_succ_node_id
Handle New Node Join:
Two approaches:
1)	First node 5554 stores all information & when a new node joins, 5554 places it at appropriate place and adjusts related node_id & their successor & previous
2)	Node places itself recursively calling successor nodes.
Node contacts 5554 first, 
if new_node  falls between 5554 & successor(5554), fixes itself
else new_node contacts successor(5554) and process repeats until it places itself.
	(this requires, a way for node to know if it is placed in the system, a message to new node node may be required.)
IMP: If finger tables are present even the node join takes log (No_of_node) steps
Step 1 appears to have a central dependency, which can be avoided to some extent by following second approach.
Another Problem Arises:
How do nodes handle different requests?
1)	Node join request
2)	Message forward request (for the get(key) implementation
3)	Message reply request (when a key is found, it directly reply’s to the source)
Since there can only be a single server running on the machine for a given port, and only port is opened in the given input script, all the three different requests must be handled.
One approach to do this is: upon each new connection receive a message (an Object)
	So, if the message has some information to identify the above three cases, the issue is solved.
	This implies upon a new Node connection, and message forward request, message reply request, node includes identification information and sends an object.
One best idea is to pass messages as Objects, (Object Serialization)
Where we read and write objects using Object Stream wrapper on top of input streams.

Since everyone should implement the same idea, it’s IMP to agree on one idea. Add inputs to this document where required, and feel free to change it.

(MAKE USE OF Review -> (New Comment (or) Track Changes options to quickly identify new changes.)
Lets’ agree upon an idea by tomorrow 12 Noon time

This is not actual project design document, but it will be based on the ideas discussed here.
 
Things to remember:
Project URI:			content://edu.buffalo.cse.cse486_586.simpledht.provider
Package of the project:		edu.buffalo.cse.cse486_586.simpledht
Package of the Content Provider:	edu.buffalo.cse.cse486_586.simpledht.provider
Project Name:			SimpleDHT



= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages